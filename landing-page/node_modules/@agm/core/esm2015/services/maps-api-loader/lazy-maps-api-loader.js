import * as tslib_1 from "tslib";
import { Inject, Injectable, InjectionToken, LOCALE_ID, Optional } from '@angular/core';
import { DocumentRef, WindowRef } from '../../utils/browser-globals';
import { MapsAPILoader } from './maps-api-loader';
import * as ɵngcc0 from '@angular/core';
export var GoogleMapsScriptProtocol;
(function (GoogleMapsScriptProtocol) {
    GoogleMapsScriptProtocol[GoogleMapsScriptProtocol["HTTP"] = 1] = "HTTP";
    GoogleMapsScriptProtocol[GoogleMapsScriptProtocol["HTTPS"] = 2] = "HTTPS";
    GoogleMapsScriptProtocol[GoogleMapsScriptProtocol["AUTO"] = 3] = "AUTO";
})(GoogleMapsScriptProtocol || (GoogleMapsScriptProtocol = {}));
/**
 * Token for the config of the LazyMapsAPILoader. Please provide an object of type {@link
 * LazyMapsAPILoaderConfig}.
 */
export const LAZY_MAPS_API_CONFIG = new InjectionToken('angular-google-maps LAZY_MAPS_API_CONFIG');
let LazyMapsAPILoader = class LazyMapsAPILoader extends MapsAPILoader {
    constructor(config = null, w, d, localeId) {
        super();
        this.localeId = localeId;
        this._SCRIPT_ID = 'agmGoogleMapsApiScript';
        this.callbackName = `agmLazyMapsAPILoader`;
        this._config = config || {};
        this._windowRef = w;
        this._documentRef = d;
    }
    load() {
        const window = this._windowRef.getNativeWindow();
        if (window.google && window.google.maps) {
            // Google maps already loaded on the page.
            return Promise.resolve();
        }
        if (this._scriptLoadingPromise) {
            return this._scriptLoadingPromise;
        }
        // this can happen in HMR situations or Stackblitz.io editors.
        const scriptOnPage = this._documentRef.getNativeDocument().getElementById(this._SCRIPT_ID);
        if (scriptOnPage) {
            this._assignScriptLoadingPromise(scriptOnPage);
            return this._scriptLoadingPromise;
        }
        const script = this._documentRef.getNativeDocument().createElement('script');
        script.type = 'text/javascript';
        script.async = true;
        script.defer = true;
        script.id = this._SCRIPT_ID;
        script.src = this._getScriptSrc(this.callbackName);
        this._assignScriptLoadingPromise(script);
        this._documentRef.getNativeDocument().body.appendChild(script);
        return this._scriptLoadingPromise;
    }
    _assignScriptLoadingPromise(scriptElem) {
        this._scriptLoadingPromise = new Promise((resolve, reject) => {
            this._windowRef.getNativeWindow()[this.callbackName] = () => {
                resolve();
            };
            scriptElem.onerror = (error) => {
                reject(error);
            };
        });
    }
    _getScriptSrc(callbackName) {
        let protocolType = (this._config && this._config.protocol) || GoogleMapsScriptProtocol.HTTPS;
        let protocol;
        switch (protocolType) {
            case GoogleMapsScriptProtocol.AUTO:
                protocol = '';
                break;
            case GoogleMapsScriptProtocol.HTTP:
                protocol = 'http:';
                break;
            case GoogleMapsScriptProtocol.HTTPS:
                protocol = 'https:';
                break;
        }
        const hostAndPath = this._config.hostAndPath || 'maps.googleapis.com/maps/api/js';
        const queryParams = {
            v: this._config.apiVersion || 'quarterly',
            callback: callbackName,
            key: this._config.apiKey,
            client: this._config.clientId,
            channel: this._config.channel,
            libraries: this._config.libraries,
            region: this._config.region,
            language: this._config.language || this.localeId !== 'en-US' ? this.localeId : null,
        };
        const params = Object.keys(queryParams)
            .filter((k) => queryParams[k] != null)
            .filter((k) => {
            // remove empty arrays
            return !Array.isArray(queryParams[k]) ||
                (Array.isArray(queryParams[k]) && queryParams[k].length > 0);
        })
            .map((k) => {
            // join arrays as comma seperated strings
            let i = queryParams[k];
            if (Array.isArray(i)) {
                return { key: k, value: i.join(',') };
            }
            return { key: k, value: queryParams[k] };
        })
            .map((entry) => {
            return `${entry.key}=${entry.value}`;
        })
            .join('&');
        return `${protocol}//${hostAndPath}?${params}`;
    }
};
LazyMapsAPILoader.ɵfac = function LazyMapsAPILoader_Factory(t) { return new (t || LazyMapsAPILoader)(ɵngcc0.ɵɵinject(LAZY_MAPS_API_CONFIG, 8), ɵngcc0.ɵɵinject(WindowRef), ɵngcc0.ɵɵinject(DocumentRef), ɵngcc0.ɵɵinject(LOCALE_ID)); };
LazyMapsAPILoader.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: LazyMapsAPILoader, factory: LazyMapsAPILoader.ɵfac });
LazyMapsAPILoader.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [LAZY_MAPS_API_CONFIG,] }] },
    { type: WindowRef },
    { type: DocumentRef },
    { type: String, decorators: [{ type: Inject, args: [LOCALE_ID,] }] }
];
LazyMapsAPILoader = tslib_1.__decorate([ tslib_1.__param(0, Optional()), tslib_1.__param(0, Inject(LAZY_MAPS_API_CONFIG)),
    tslib_1.__param(3, Inject(LOCALE_ID)),
    tslib_1.__metadata("design:paramtypes", [Object, WindowRef, DocumentRef, String])
], LazyMapsAPILoader);
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(LazyMapsAPILoader, [{
        type: Injectable
    }], function () { return [{ type: undefined, decorators: [{
                type: Optional
            }, {
                type: Inject,
                args: [LAZY_MAPS_API_CONFIG]
            }] }, { type: WindowRef }, { type: DocumentRef }, { type: String, decorators: [{
                type: Inject,
                args: [LOCALE_ID]
            }] }]; }, null); })();
export { LazyMapsAPILoader };

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIkM6L1VzZXJzL3VzZXIvRGVza3RvcC9QUk9KRUNUUy9TVFVBTkEvSWRleVBheS90b3ZvLWFuZ3VsYXItOS1hcHAtbGFuZGluZy1wYWdlL25vZGVfbW9kdWxlcy9AYWdtL2NvcmUvZXNtMjAxNS9zZXJ2aWNlcy9tYXBzLWFwaS1sb2FkZXIvbGF6eS1tYXBzLWFwaS1sb2FkZXIuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7O0FBSUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O21IQXNHRTs7Ozs7Ozt3Q0FPc0MsQUFFckM7Ozs7Ozs7Ozs7Ozs7O2tDQUdtQiIsImZpbGUiOiJsYXp5LW1hcHMtYXBpLWxvYWRlci5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIHRzbGliXzEgZnJvbSBcInRzbGliXCI7XG5pbXBvcnQgeyBJbmplY3QsIEluamVjdGFibGUsIEluamVjdGlvblRva2VuLCBMT0NBTEVfSUQsIE9wdGlvbmFsIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBEb2N1bWVudFJlZiwgV2luZG93UmVmIH0gZnJvbSAnLi4vLi4vdXRpbHMvYnJvd3Nlci1nbG9iYWxzJztcbmltcG9ydCB7IE1hcHNBUElMb2FkZXIgfSBmcm9tICcuL21hcHMtYXBpLWxvYWRlcic7XG5leHBvcnQgdmFyIEdvb2dsZU1hcHNTY3JpcHRQcm90b2NvbDtcbihmdW5jdGlvbiAoR29vZ2xlTWFwc1NjcmlwdFByb3RvY29sKSB7XG4gICAgR29vZ2xlTWFwc1NjcmlwdFByb3RvY29sW0dvb2dsZU1hcHNTY3JpcHRQcm90b2NvbFtcIkhUVFBcIl0gPSAxXSA9IFwiSFRUUFwiO1xuICAgIEdvb2dsZU1hcHNTY3JpcHRQcm90b2NvbFtHb29nbGVNYXBzU2NyaXB0UHJvdG9jb2xbXCJIVFRQU1wiXSA9IDJdID0gXCJIVFRQU1wiO1xuICAgIEdvb2dsZU1hcHNTY3JpcHRQcm90b2NvbFtHb29nbGVNYXBzU2NyaXB0UHJvdG9jb2xbXCJBVVRPXCJdID0gM10gPSBcIkFVVE9cIjtcbn0pKEdvb2dsZU1hcHNTY3JpcHRQcm90b2NvbCB8fCAoR29vZ2xlTWFwc1NjcmlwdFByb3RvY29sID0ge30pKTtcbi8qKlxuICogVG9rZW4gZm9yIHRoZSBjb25maWcgb2YgdGhlIExhenlNYXBzQVBJTG9hZGVyLiBQbGVhc2UgcHJvdmlkZSBhbiBvYmplY3Qgb2YgdHlwZSB7QGxpbmtcbiAqIExhenlNYXBzQVBJTG9hZGVyQ29uZmlnfS5cbiAqL1xuZXhwb3J0IGNvbnN0IExBWllfTUFQU19BUElfQ09ORklHID0gbmV3IEluamVjdGlvblRva2VuKCdhbmd1bGFyLWdvb2dsZS1tYXBzIExBWllfTUFQU19BUElfQ09ORklHJyk7XG5sZXQgTGF6eU1hcHNBUElMb2FkZXIgPSBjbGFzcyBMYXp5TWFwc0FQSUxvYWRlciBleHRlbmRzIE1hcHNBUElMb2FkZXIge1xuICAgIGNvbnN0cnVjdG9yKGNvbmZpZyA9IG51bGwsIHcsIGQsIGxvY2FsZUlkKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMubG9jYWxlSWQgPSBsb2NhbGVJZDtcbiAgICAgICAgdGhpcy5fU0NSSVBUX0lEID0gJ2FnbUdvb2dsZU1hcHNBcGlTY3JpcHQnO1xuICAgICAgICB0aGlzLmNhbGxiYWNrTmFtZSA9IGBhZ21MYXp5TWFwc0FQSUxvYWRlcmA7XG4gICAgICAgIHRoaXMuX2NvbmZpZyA9IGNvbmZpZyB8fCB7fTtcbiAgICAgICAgdGhpcy5fd2luZG93UmVmID0gdztcbiAgICAgICAgdGhpcy5fZG9jdW1lbnRSZWYgPSBkO1xuICAgIH1cbiAgICBsb2FkKCkge1xuICAgICAgICBjb25zdCB3aW5kb3cgPSB0aGlzLl93aW5kb3dSZWYuZ2V0TmF0aXZlV2luZG93KCk7XG4gICAgICAgIGlmICh3aW5kb3cuZ29vZ2xlICYmIHdpbmRvdy5nb29nbGUubWFwcykge1xuICAgICAgICAgICAgLy8gR29vZ2xlIG1hcHMgYWxyZWFkeSBsb2FkZWQgb24gdGhlIHBhZ2UuXG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX3NjcmlwdExvYWRpbmdQcm9taXNlKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fc2NyaXB0TG9hZGluZ1Byb21pc2U7XG4gICAgICAgIH1cbiAgICAgICAgLy8gdGhpcyBjYW4gaGFwcGVuIGluIEhNUiBzaXR1YXRpb25zIG9yIFN0YWNrYmxpdHouaW8gZWRpdG9ycy5cbiAgICAgICAgY29uc3Qgc2NyaXB0T25QYWdlID0gdGhpcy5fZG9jdW1lbnRSZWYuZ2V0TmF0aXZlRG9jdW1lbnQoKS5nZXRFbGVtZW50QnlJZCh0aGlzLl9TQ1JJUFRfSUQpO1xuICAgICAgICBpZiAoc2NyaXB0T25QYWdlKSB7XG4gICAgICAgICAgICB0aGlzLl9hc3NpZ25TY3JpcHRMb2FkaW5nUHJvbWlzZShzY3JpcHRPblBhZ2UpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3NjcmlwdExvYWRpbmdQcm9taXNlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNjcmlwdCA9IHRoaXMuX2RvY3VtZW50UmVmLmdldE5hdGl2ZURvY3VtZW50KCkuY3JlYXRlRWxlbWVudCgnc2NyaXB0Jyk7XG4gICAgICAgIHNjcmlwdC50eXBlID0gJ3RleHQvamF2YXNjcmlwdCc7XG4gICAgICAgIHNjcmlwdC5hc3luYyA9IHRydWU7XG4gICAgICAgIHNjcmlwdC5kZWZlciA9IHRydWU7XG4gICAgICAgIHNjcmlwdC5pZCA9IHRoaXMuX1NDUklQVF9JRDtcbiAgICAgICAgc2NyaXB0LnNyYyA9IHRoaXMuX2dldFNjcmlwdFNyYyh0aGlzLmNhbGxiYWNrTmFtZSk7XG4gICAgICAgIHRoaXMuX2Fzc2lnblNjcmlwdExvYWRpbmdQcm9taXNlKHNjcmlwdCk7XG4gICAgICAgIHRoaXMuX2RvY3VtZW50UmVmLmdldE5hdGl2ZURvY3VtZW50KCkuYm9keS5hcHBlbmRDaGlsZChzY3JpcHQpO1xuICAgICAgICByZXR1cm4gdGhpcy5fc2NyaXB0TG9hZGluZ1Byb21pc2U7XG4gICAgfVxuICAgIF9hc3NpZ25TY3JpcHRMb2FkaW5nUHJvbWlzZShzY3JpcHRFbGVtKSB7XG4gICAgICAgIHRoaXMuX3NjcmlwdExvYWRpbmdQcm9taXNlID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5fd2luZG93UmVmLmdldE5hdGl2ZVdpbmRvdygpW3RoaXMuY2FsbGJhY2tOYW1lXSA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgc2NyaXB0RWxlbS5vbmVycm9yID0gKGVycm9yKSA9PiB7XG4gICAgICAgICAgICAgICAgcmVqZWN0KGVycm9yKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBfZ2V0U2NyaXB0U3JjKGNhbGxiYWNrTmFtZSkge1xuICAgICAgICBsZXQgcHJvdG9jb2xUeXBlID0gKHRoaXMuX2NvbmZpZyAmJiB0aGlzLl9jb25maWcucHJvdG9jb2wpIHx8IEdvb2dsZU1hcHNTY3JpcHRQcm90b2NvbC5IVFRQUztcbiAgICAgICAgbGV0IHByb3RvY29sO1xuICAgICAgICBzd2l0Y2ggKHByb3RvY29sVHlwZSkge1xuICAgICAgICAgICAgY2FzZSBHb29nbGVNYXBzU2NyaXB0UHJvdG9jb2wuQVVUTzpcbiAgICAgICAgICAgICAgICBwcm90b2NvbCA9ICcnO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBHb29nbGVNYXBzU2NyaXB0UHJvdG9jb2wuSFRUUDpcbiAgICAgICAgICAgICAgICBwcm90b2NvbCA9ICdodHRwOic7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIEdvb2dsZU1hcHNTY3JpcHRQcm90b2NvbC5IVFRQUzpcbiAgICAgICAgICAgICAgICBwcm90b2NvbCA9ICdodHRwczonO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGhvc3RBbmRQYXRoID0gdGhpcy5fY29uZmlnLmhvc3RBbmRQYXRoIHx8ICdtYXBzLmdvb2dsZWFwaXMuY29tL21hcHMvYXBpL2pzJztcbiAgICAgICAgY29uc3QgcXVlcnlQYXJhbXMgPSB7XG4gICAgICAgICAgICB2OiB0aGlzLl9jb25maWcuYXBpVmVyc2lvbiB8fCAncXVhcnRlcmx5JyxcbiAgICAgICAgICAgIGNhbGxiYWNrOiBjYWxsYmFja05hbWUsXG4gICAgICAgICAgICBrZXk6IHRoaXMuX2NvbmZpZy5hcGlLZXksXG4gICAgICAgICAgICBjbGllbnQ6IHRoaXMuX2NvbmZpZy5jbGllbnRJZCxcbiAgICAgICAgICAgIGNoYW5uZWw6IHRoaXMuX2NvbmZpZy5jaGFubmVsLFxuICAgICAgICAgICAgbGlicmFyaWVzOiB0aGlzLl9jb25maWcubGlicmFyaWVzLFxuICAgICAgICAgICAgcmVnaW9uOiB0aGlzLl9jb25maWcucmVnaW9uLFxuICAgICAgICAgICAgbGFuZ3VhZ2U6IHRoaXMuX2NvbmZpZy5sYW5ndWFnZSB8fCB0aGlzLmxvY2FsZUlkICE9PSAnZW4tVVMnID8gdGhpcy5sb2NhbGVJZCA6IG51bGwsXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHBhcmFtcyA9IE9iamVjdC5rZXlzKHF1ZXJ5UGFyYW1zKVxuICAgICAgICAgICAgLmZpbHRlcigoaykgPT4gcXVlcnlQYXJhbXNba10gIT0gbnVsbClcbiAgICAgICAgICAgIC5maWx0ZXIoKGspID0+IHtcbiAgICAgICAgICAgIC8vIHJlbW92ZSBlbXB0eSBhcnJheXNcbiAgICAgICAgICAgIHJldHVybiAhQXJyYXkuaXNBcnJheShxdWVyeVBhcmFtc1trXSkgfHxcbiAgICAgICAgICAgICAgICAoQXJyYXkuaXNBcnJheShxdWVyeVBhcmFtc1trXSkgJiYgcXVlcnlQYXJhbXNba10ubGVuZ3RoID4gMCk7XG4gICAgICAgIH0pXG4gICAgICAgICAgICAubWFwKChrKSA9PiB7XG4gICAgICAgICAgICAvLyBqb2luIGFycmF5cyBhcyBjb21tYSBzZXBlcmF0ZWQgc3RyaW5nc1xuICAgICAgICAgICAgbGV0IGkgPSBxdWVyeVBhcmFtc1trXTtcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGkpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsga2V5OiBrLCB2YWx1ZTogaS5qb2luKCcsJykgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7IGtleTogaywgdmFsdWU6IHF1ZXJ5UGFyYW1zW2tdIH07XG4gICAgICAgIH0pXG4gICAgICAgICAgICAubWFwKChlbnRyeSkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIGAke2VudHJ5LmtleX09JHtlbnRyeS52YWx1ZX1gO1xuICAgICAgICB9KVxuICAgICAgICAgICAgLmpvaW4oJyYnKTtcbiAgICAgICAgcmV0dXJuIGAke3Byb3RvY29sfS8vJHtob3N0QW5kUGF0aH0/JHtwYXJhbXN9YDtcbiAgICB9XG59O1xuTGF6eU1hcHNBUElMb2FkZXIuY3RvclBhcmFtZXRlcnMgPSAoKSA9PiBbXG4gICAgeyB0eXBlOiB1bmRlZmluZWQsIGRlY29yYXRvcnM6IFt7IHR5cGU6IE9wdGlvbmFsIH0sIHsgdHlwZTogSW5qZWN0LCBhcmdzOiBbTEFaWV9NQVBTX0FQSV9DT05GSUcsXSB9XSB9LFxuICAgIHsgdHlwZTogV2luZG93UmVmIH0sXG4gICAgeyB0eXBlOiBEb2N1bWVudFJlZiB9LFxuICAgIHsgdHlwZTogU3RyaW5nLCBkZWNvcmF0b3JzOiBbeyB0eXBlOiBJbmplY3QsIGFyZ3M6IFtMT0NBTEVfSUQsXSB9XSB9XG5dO1xuTGF6eU1hcHNBUElMb2FkZXIgPSB0c2xpYl8xLl9fZGVjb3JhdGUoW1xuICAgIEluamVjdGFibGUoKSxcbiAgICB0c2xpYl8xLl9fcGFyYW0oMCwgT3B0aW9uYWwoKSksIHRzbGliXzEuX19wYXJhbSgwLCBJbmplY3QoTEFaWV9NQVBTX0FQSV9DT05GSUcpKSxcbiAgICB0c2xpYl8xLl9fcGFyYW0oMywgSW5qZWN0KExPQ0FMRV9JRCkpLFxuICAgIHRzbGliXzEuX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtPYmplY3QsIFdpbmRvd1JlZiwgRG9jdW1lbnRSZWYsIFN0cmluZ10pXG5dLCBMYXp5TWFwc0FQSUxvYWRlcik7XG5leHBvcnQgeyBMYXp5TWFwc0FQSUxvYWRlciB9O1xuIl19