import * as tslib_1 from "tslib";
import { Injectable, NgZone } from '@angular/core';
import { merge, Observable } from 'rxjs';
import { map, skip, startWith, switchMap } from 'rxjs/operators';
import { createMVCEventObservable } from '../../utils/mvcarray-utils';
import { GoogleMapsAPIWrapper } from '../google-maps-api-wrapper';
import * as ɵngcc0 from '@angular/core';
let PolygonManager = class PolygonManager {
    constructor(_mapsWrapper, _zone) {
        this._mapsWrapper = _mapsWrapper;
        this._zone = _zone;
        this._polygons = new Map();
    }
    addPolygon(path) {
        const polygonPromise = this._mapsWrapper.createPolygon({
            clickable: path.clickable,
            draggable: path.draggable,
            editable: path.editable,
            fillColor: path.fillColor,
            fillOpacity: path.fillOpacity,
            geodesic: path.geodesic,
            paths: path.paths,
            strokeColor: path.strokeColor,
            strokeOpacity: path.strokeOpacity,
            strokeWeight: path.strokeWeight,
            visible: path.visible,
            zIndex: path.zIndex,
        });
        this._polygons.set(path, polygonPromise);
    }
    updatePolygon(polygon) {
        const m = this._polygons.get(polygon);
        if (m == null) {
            return Promise.resolve();
        }
        return m.then((l) => this._zone.run(() => { l.setPaths(polygon.paths); }));
    }
    setPolygonOptions(path, options) {
        return this._polygons.get(path).then((l) => { l.setOptions(options); });
    }
    deletePolygon(paths) {
        const m = this._polygons.get(paths);
        if (m == null) {
            return Promise.resolve();
        }
        return m.then((l) => {
            return this._zone.run(() => {
                l.setMap(null);
                this._polygons.delete(paths);
            });
        });
    }
    getPath(polygon) {
        return this._polygons.get(polygon)
            .then((polygon) => polygon.getPath().getArray());
    }
    getPaths(polygon) {
        return this._polygons.get(polygon)
            .then((polygon) => polygon.getPaths().getArray().map((p) => p.getArray()));
    }
    createEventObservable(eventName, path) {
        return new Observable((observer) => {
            this._polygons.get(path).then((l) => {
                l.addListener(eventName, (e) => this._zone.run(() => observer.next(e)));
            });
        });
    }
    createPathEventObservable(agmPolygon) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const polygon = yield this._polygons.get(agmPolygon);
            const paths = polygon.getPaths();
            const pathsChanges$ = createMVCEventObservable(paths);
            return pathsChanges$.pipe(startWith({ newArr: paths.getArray() }), // in order to subscribe to them all
            switchMap(parentMVEvent => merge(... // rest parameter
            parentMVEvent.newArr.map((chMVC, index) => createMVCEventObservable(chMVC)
                .pipe(map(chMVCEvent => ({ parentMVEvent, chMVCEvent, pathIndex: index })))))
                .pipe(startWith({ parentMVEvent, chMVCEvent: null, pathIndex: null }))), // start the merged ob with an event signinifing change to parent
            skip(1), // skip the manually added event
            map(({ parentMVEvent, chMVCEvent, pathIndex }) => {
                let retVal;
                if (!chMVCEvent) {
                    retVal = {
                        newArr: parentMVEvent.newArr.map(subArr => subArr.getArray().map(latLng => latLng.toJSON())),
                        eventName: parentMVEvent.evName,
                        index: parentMVEvent.index,
                    };
                    if (parentMVEvent.previous) {
                        retVal.previous = parentMVEvent.previous.getArray();
                    }
                }
                else {
                    retVal = {
                        newArr: parentMVEvent.newArr.map(subArr => subArr.getArray().map(latLng => latLng.toJSON())),
                        pathIndex,
                        eventName: chMVCEvent.evName,
                        index: chMVCEvent.index,
                    };
                    if (chMVCEvent.previous) {
                        retVal.previous = chMVCEvent.previous;
                    }
                }
                return retVal;
            }));
        });
    }
};
PolygonManager.ɵfac = function PolygonManager_Factory(t) { return new (t || PolygonManager)(ɵngcc0.ɵɵinject(GoogleMapsAPIWrapper), ɵngcc0.ɵɵinject(ɵngcc0.NgZone)); };
PolygonManager.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: PolygonManager, factory: PolygonManager.ɵfac });
PolygonManager.ctorParameters = () => [
    { type: GoogleMapsAPIWrapper },
    { type: NgZone }
];
PolygonManager = tslib_1.__decorate([ tslib_1.__metadata("design:paramtypes", [GoogleMapsAPIWrapper, NgZone])
], PolygonManager);
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(PolygonManager, [{
        type: Injectable
    }], function () { return [{ type: GoogleMapsAPIWrapper }, { type: ɵngcc0.NgZone }]; }, null); })();
export { PolygonManager };

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIkM6L1VzZXJzL3VzZXIvRGVza3RvcC9QUk9KRUNUUy9TVFVBTkEvSWRleVBheS90b3ZvLWFuZ3VsYXItOS1hcHAtbGFuZGluZy1wYWdlL25vZGVfbW9kdWxlcy9AYWdtL2NvcmUvZXNtMjAxNS9zZXJ2aWNlcy9tYW5hZ2Vycy9wb2x5Z29uLW1hbmFnZXIuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Ozs7QUFNQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzswR0FrR0U7Ozs7O3FDQUttQyxBQUVsQzs7Ozt1R0FDZ0IiLCJmaWxlIjoicG9seWdvbi1tYW5hZ2VyLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgdHNsaWJfMSBmcm9tIFwidHNsaWJcIjtcbmltcG9ydCB7IEluamVjdGFibGUsIE5nWm9uZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgbWVyZ2UsIE9ic2VydmFibGUgfSBmcm9tICdyeGpzJztcbmltcG9ydCB7IG1hcCwgc2tpcCwgc3RhcnRXaXRoLCBzd2l0Y2hNYXAgfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XG5pbXBvcnQgeyBjcmVhdGVNVkNFdmVudE9ic2VydmFibGUgfSBmcm9tICcuLi8uLi91dGlscy9tdmNhcnJheS11dGlscyc7XG5pbXBvcnQgeyBHb29nbGVNYXBzQVBJV3JhcHBlciB9IGZyb20gJy4uL2dvb2dsZS1tYXBzLWFwaS13cmFwcGVyJztcbmxldCBQb2x5Z29uTWFuYWdlciA9IGNsYXNzIFBvbHlnb25NYW5hZ2VyIHtcbiAgICBjb25zdHJ1Y3RvcihfbWFwc1dyYXBwZXIsIF96b25lKSB7XG4gICAgICAgIHRoaXMuX21hcHNXcmFwcGVyID0gX21hcHNXcmFwcGVyO1xuICAgICAgICB0aGlzLl96b25lID0gX3pvbmU7XG4gICAgICAgIHRoaXMuX3BvbHlnb25zID0gbmV3IE1hcCgpO1xuICAgIH1cbiAgICBhZGRQb2x5Z29uKHBhdGgpIHtcbiAgICAgICAgY29uc3QgcG9seWdvblByb21pc2UgPSB0aGlzLl9tYXBzV3JhcHBlci5jcmVhdGVQb2x5Z29uKHtcbiAgICAgICAgICAgIGNsaWNrYWJsZTogcGF0aC5jbGlja2FibGUsXG4gICAgICAgICAgICBkcmFnZ2FibGU6IHBhdGguZHJhZ2dhYmxlLFxuICAgICAgICAgICAgZWRpdGFibGU6IHBhdGguZWRpdGFibGUsXG4gICAgICAgICAgICBmaWxsQ29sb3I6IHBhdGguZmlsbENvbG9yLFxuICAgICAgICAgICAgZmlsbE9wYWNpdHk6IHBhdGguZmlsbE9wYWNpdHksXG4gICAgICAgICAgICBnZW9kZXNpYzogcGF0aC5nZW9kZXNpYyxcbiAgICAgICAgICAgIHBhdGhzOiBwYXRoLnBhdGhzLFxuICAgICAgICAgICAgc3Ryb2tlQ29sb3I6IHBhdGguc3Ryb2tlQ29sb3IsXG4gICAgICAgICAgICBzdHJva2VPcGFjaXR5OiBwYXRoLnN0cm9rZU9wYWNpdHksXG4gICAgICAgICAgICBzdHJva2VXZWlnaHQ6IHBhdGguc3Ryb2tlV2VpZ2h0LFxuICAgICAgICAgICAgdmlzaWJsZTogcGF0aC52aXNpYmxlLFxuICAgICAgICAgICAgekluZGV4OiBwYXRoLnpJbmRleCxcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuX3BvbHlnb25zLnNldChwYXRoLCBwb2x5Z29uUHJvbWlzZSk7XG4gICAgfVxuICAgIHVwZGF0ZVBvbHlnb24ocG9seWdvbikge1xuICAgICAgICBjb25zdCBtID0gdGhpcy5fcG9seWdvbnMuZ2V0KHBvbHlnb24pO1xuICAgICAgICBpZiAobSA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG0udGhlbigobCkgPT4gdGhpcy5fem9uZS5ydW4oKCkgPT4geyBsLnNldFBhdGhzKHBvbHlnb24ucGF0aHMpOyB9KSk7XG4gICAgfVxuICAgIHNldFBvbHlnb25PcHRpb25zKHBhdGgsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3BvbHlnb25zLmdldChwYXRoKS50aGVuKChsKSA9PiB7IGwuc2V0T3B0aW9ucyhvcHRpb25zKTsgfSk7XG4gICAgfVxuICAgIGRlbGV0ZVBvbHlnb24ocGF0aHMpIHtcbiAgICAgICAgY29uc3QgbSA9IHRoaXMuX3BvbHlnb25zLmdldChwYXRocyk7XG4gICAgICAgIGlmIChtID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbS50aGVuKChsKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fem9uZS5ydW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgIGwuc2V0TWFwKG51bGwpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3BvbHlnb25zLmRlbGV0ZShwYXRocyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGdldFBhdGgocG9seWdvbikge1xuICAgICAgICByZXR1cm4gdGhpcy5fcG9seWdvbnMuZ2V0KHBvbHlnb24pXG4gICAgICAgICAgICAudGhlbigocG9seWdvbikgPT4gcG9seWdvbi5nZXRQYXRoKCkuZ2V0QXJyYXkoKSk7XG4gICAgfVxuICAgIGdldFBhdGhzKHBvbHlnb24pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3BvbHlnb25zLmdldChwb2x5Z29uKVxuICAgICAgICAgICAgLnRoZW4oKHBvbHlnb24pID0+IHBvbHlnb24uZ2V0UGF0aHMoKS5nZXRBcnJheSgpLm1hcCgocCkgPT4gcC5nZXRBcnJheSgpKSk7XG4gICAgfVxuICAgIGNyZWF0ZUV2ZW50T2JzZXJ2YWJsZShldmVudE5hbWUsIHBhdGgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBPYnNlcnZhYmxlKChvYnNlcnZlcikgPT4ge1xuICAgICAgICAgICAgdGhpcy5fcG9seWdvbnMuZ2V0KHBhdGgpLnRoZW4oKGwpID0+IHtcbiAgICAgICAgICAgICAgICBsLmFkZExpc3RlbmVyKGV2ZW50TmFtZSwgKGUpID0+IHRoaXMuX3pvbmUucnVuKCgpID0+IG9ic2VydmVyLm5leHQoZSkpKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgY3JlYXRlUGF0aEV2ZW50T2JzZXJ2YWJsZShhZ21Qb2x5Z29uKSB7XG4gICAgICAgIHJldHVybiB0c2xpYl8xLl9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHBvbHlnb24gPSB5aWVsZCB0aGlzLl9wb2x5Z29ucy5nZXQoYWdtUG9seWdvbik7XG4gICAgICAgICAgICBjb25zdCBwYXRocyA9IHBvbHlnb24uZ2V0UGF0aHMoKTtcbiAgICAgICAgICAgIGNvbnN0IHBhdGhzQ2hhbmdlcyQgPSBjcmVhdGVNVkNFdmVudE9ic2VydmFibGUocGF0aHMpO1xuICAgICAgICAgICAgcmV0dXJuIHBhdGhzQ2hhbmdlcyQucGlwZShzdGFydFdpdGgoeyBuZXdBcnI6IHBhdGhzLmdldEFycmF5KCkgfSksIC8vIGluIG9yZGVyIHRvIHN1YnNjcmliZSB0byB0aGVtIGFsbFxuICAgICAgICAgICAgc3dpdGNoTWFwKHBhcmVudE1WRXZlbnQgPT4gbWVyZ2UoLi4uIC8vIHJlc3QgcGFyYW1ldGVyXG4gICAgICAgICAgICBwYXJlbnRNVkV2ZW50Lm5ld0Fyci5tYXAoKGNoTVZDLCBpbmRleCkgPT4gY3JlYXRlTVZDRXZlbnRPYnNlcnZhYmxlKGNoTVZDKVxuICAgICAgICAgICAgICAgIC5waXBlKG1hcChjaE1WQ0V2ZW50ID0+ICh7IHBhcmVudE1WRXZlbnQsIGNoTVZDRXZlbnQsIHBhdGhJbmRleDogaW5kZXggfSkpKSkpXG4gICAgICAgICAgICAgICAgLnBpcGUoc3RhcnRXaXRoKHsgcGFyZW50TVZFdmVudCwgY2hNVkNFdmVudDogbnVsbCwgcGF0aEluZGV4OiBudWxsIH0pKSksIC8vIHN0YXJ0IHRoZSBtZXJnZWQgb2Igd2l0aCBhbiBldmVudCBzaWduaW5pZmluZyBjaGFuZ2UgdG8gcGFyZW50XG4gICAgICAgICAgICBza2lwKDEpLCAvLyBza2lwIHRoZSBtYW51YWxseSBhZGRlZCBldmVudFxuICAgICAgICAgICAgbWFwKCh7IHBhcmVudE1WRXZlbnQsIGNoTVZDRXZlbnQsIHBhdGhJbmRleCB9KSA9PiB7XG4gICAgICAgICAgICAgICAgbGV0IHJldFZhbDtcbiAgICAgICAgICAgICAgICBpZiAoIWNoTVZDRXZlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0VmFsID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV3QXJyOiBwYXJlbnRNVkV2ZW50Lm5ld0Fyci5tYXAoc3ViQXJyID0+IHN1YkFyci5nZXRBcnJheSgpLm1hcChsYXRMbmcgPT4gbGF0TG5nLnRvSlNPTigpKSksXG4gICAgICAgICAgICAgICAgICAgICAgICBldmVudE5hbWU6IHBhcmVudE1WRXZlbnQuZXZOYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXg6IHBhcmVudE1WRXZlbnQuaW5kZXgsXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIGlmIChwYXJlbnRNVkV2ZW50LnByZXZpb3VzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXRWYWwucHJldmlvdXMgPSBwYXJlbnRNVkV2ZW50LnByZXZpb3VzLmdldEFycmF5KCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldFZhbCA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld0FycjogcGFyZW50TVZFdmVudC5uZXdBcnIubWFwKHN1YkFyciA9PiBzdWJBcnIuZ2V0QXJyYXkoKS5tYXAobGF0TG5nID0+IGxhdExuZy50b0pTT04oKSkpLFxuICAgICAgICAgICAgICAgICAgICAgICAgcGF0aEluZGV4LFxuICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnROYW1lOiBjaE1WQ0V2ZW50LmV2TmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4OiBjaE1WQ0V2ZW50LmluZGV4LFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2hNVkNFdmVudC5wcmV2aW91cykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0VmFsLnByZXZpb3VzID0gY2hNVkNFdmVudC5wcmV2aW91cztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gcmV0VmFsO1xuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9KTtcbiAgICB9XG59O1xuUG9seWdvbk1hbmFnZXIuY3RvclBhcmFtZXRlcnMgPSAoKSA9PiBbXG4gICAgeyB0eXBlOiBHb29nbGVNYXBzQVBJV3JhcHBlciB9LFxuICAgIHsgdHlwZTogTmdab25lIH1cbl07XG5Qb2x5Z29uTWFuYWdlciA9IHRzbGliXzEuX19kZWNvcmF0ZShbXG4gICAgSW5qZWN0YWJsZSgpLFxuICAgIHRzbGliXzEuX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtHb29nbGVNYXBzQVBJV3JhcHBlciwgTmdab25lXSlcbl0sIFBvbHlnb25NYW5hZ2VyKTtcbmV4cG9ydCB7IFBvbHlnb25NYW5hZ2VyIH07XG4iXX0=