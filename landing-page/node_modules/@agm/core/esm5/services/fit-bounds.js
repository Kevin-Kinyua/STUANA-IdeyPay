import * as tslib_1 from "tslib";
import { Injectable } from '@angular/core';
import { BehaviorSubject, from, timer } from 'rxjs';
import { flatMap, map, sample, shareReplay, switchMap, } from 'rxjs/operators';
import { MapsAPILoader } from './maps-api-loader/maps-api-loader';
/**
 * Class to implement when you what to be able to make it work with the auto fit bounds feature
 * of AGM.
 */
import * as ɵngcc0 from '@angular/core';
var FitBoundsAccessor = /** @class */ (function () {
    function FitBoundsAccessor() {
    }
    return FitBoundsAccessor;
}());
export { FitBoundsAccessor };
/**
 * The FitBoundsService is responsible for computing the bounds of the a single map.
 */
var FitBoundsService = /** @class */ (function () {
    function FitBoundsService(loader) {
        var _this = this;
        this._boundsChangeSampleTime$ = new BehaviorSubject(200);
        this._includeInBounds$ = new BehaviorSubject(new Map());
        this.bounds$ = from(loader.load()).pipe(flatMap(function () { return _this._includeInBounds$; }), sample(this._boundsChangeSampleTime$.pipe(switchMap(function (time) { return timer(0, time); }))), map(function (includeInBounds) { return _this._generateBounds(includeInBounds); }), shareReplay(1));
    }
    FitBoundsService.prototype._generateBounds = function (includeInBounds) {
        var bounds = new google.maps.LatLngBounds();
        includeInBounds.forEach(function (b) { return bounds.extend(b); });
        return bounds;
    };
    FitBoundsService.prototype.addToBounds = function (latLng) {
        var id = this._createIdentifier(latLng);
        if (this._includeInBounds$.value.has(id)) {
            return;
        }
        var map = this._includeInBounds$.value;
        map.set(id, latLng);
        this._includeInBounds$.next(map);
    };
    FitBoundsService.prototype.removeFromBounds = function (latLng) {
        var map = this._includeInBounds$.value;
        map.delete(this._createIdentifier(latLng));
        this._includeInBounds$.next(map);
    };
    FitBoundsService.prototype.changeFitBoundsChangeSampleTime = function (timeMs) {
        this._boundsChangeSampleTime$.next(timeMs);
    };
    FitBoundsService.prototype.getBounds$ = function () {
        return this.bounds$;
    };
    FitBoundsService.prototype._createIdentifier = function (latLng) {
        return latLng.lat + "+" + latLng.lng;
    };
    FitBoundsService.ctorParameters = function () { return [
        { type: MapsAPILoader }
    ]; };
    FitBoundsService = tslib_1.__decorate([ tslib_1.__metadata("design:paramtypes", [MapsAPILoader])
    ], FitBoundsService);
FitBoundsService.ɵfac = function FitBoundsService_Factory(t) { return new (t || FitBoundsService)(ɵngcc0.ɵɵinject(MapsAPILoader)); };
FitBoundsService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: FitBoundsService, factory: function (t) { return FitBoundsService.ɵfac(t); } });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(FitBoundsService, [{
        type: Injectable
    }], function () { return [{ type: MapsAPILoader }]; }, null); })();
    return FitBoundsService;
}());
export { FitBoundsService };

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIkM6L1VzZXJzL3VzZXIvRGVza3RvcC9QUk9KRUNUUy9TVFVBTkEvSWRleVBheS90b3ZvLWFuZ3VsYXItOS1hcHAtbGFuZGluZy1wYWdlL25vZGVfbW9kdWxlcy9AYWdtL2NvcmUvZXNtNS9zZXJ2aWNlcy9maXQtYm91bmRzLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7Ozs7O0FBU0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzJDQStDMkMsQUFFcEM7Ozs7Ozt1RUFDa0IiLCJmaWxlIjoiZml0LWJvdW5kcy5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIHRzbGliXzEgZnJvbSBcInRzbGliXCI7XG5pbXBvcnQgeyBJbmplY3RhYmxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBCZWhhdmlvclN1YmplY3QsIGZyb20sIHRpbWVyIH0gZnJvbSAncnhqcyc7XG5pbXBvcnQgeyBmbGF0TWFwLCBtYXAsIHNhbXBsZSwgc2hhcmVSZXBsYXksIHN3aXRjaE1hcCwgfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XG5pbXBvcnQgeyBNYXBzQVBJTG9hZGVyIH0gZnJvbSAnLi9tYXBzLWFwaS1sb2FkZXIvbWFwcy1hcGktbG9hZGVyJztcbi8qKlxuICogQ2xhc3MgdG8gaW1wbGVtZW50IHdoZW4geW91IHdoYXQgdG8gYmUgYWJsZSB0byBtYWtlIGl0IHdvcmsgd2l0aCB0aGUgYXV0byBmaXQgYm91bmRzIGZlYXR1cmVcbiAqIG9mIEFHTS5cbiAqL1xudmFyIEZpdEJvdW5kc0FjY2Vzc29yID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEZpdEJvdW5kc0FjY2Vzc29yKCkge1xuICAgIH1cbiAgICByZXR1cm4gRml0Qm91bmRzQWNjZXNzb3I7XG59KCkpO1xuZXhwb3J0IHsgRml0Qm91bmRzQWNjZXNzb3IgfTtcbi8qKlxuICogVGhlIEZpdEJvdW5kc1NlcnZpY2UgaXMgcmVzcG9uc2libGUgZm9yIGNvbXB1dGluZyB0aGUgYm91bmRzIG9mIHRoZSBhIHNpbmdsZSBtYXAuXG4gKi9cbnZhciBGaXRCb3VuZHNTZXJ2aWNlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEZpdEJvdW5kc1NlcnZpY2UobG9hZGVyKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMuX2JvdW5kc0NoYW5nZVNhbXBsZVRpbWUkID0gbmV3IEJlaGF2aW9yU3ViamVjdCgyMDApO1xuICAgICAgICB0aGlzLl9pbmNsdWRlSW5Cb3VuZHMkID0gbmV3IEJlaGF2aW9yU3ViamVjdChuZXcgTWFwKCkpO1xuICAgICAgICB0aGlzLmJvdW5kcyQgPSBmcm9tKGxvYWRlci5sb2FkKCkpLnBpcGUoZmxhdE1hcChmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5faW5jbHVkZUluQm91bmRzJDsgfSksIHNhbXBsZSh0aGlzLl9ib3VuZHNDaGFuZ2VTYW1wbGVUaW1lJC5waXBlKHN3aXRjaE1hcChmdW5jdGlvbiAodGltZSkgeyByZXR1cm4gdGltZXIoMCwgdGltZSk7IH0pKSksIG1hcChmdW5jdGlvbiAoaW5jbHVkZUluQm91bmRzKSB7IHJldHVybiBfdGhpcy5fZ2VuZXJhdGVCb3VuZHMoaW5jbHVkZUluQm91bmRzKTsgfSksIHNoYXJlUmVwbGF5KDEpKTtcbiAgICB9XG4gICAgRml0Qm91bmRzU2VydmljZS5wcm90b3R5cGUuX2dlbmVyYXRlQm91bmRzID0gZnVuY3Rpb24gKGluY2x1ZGVJbkJvdW5kcykge1xuICAgICAgICB2YXIgYm91bmRzID0gbmV3IGdvb2dsZS5tYXBzLkxhdExuZ0JvdW5kcygpO1xuICAgICAgICBpbmNsdWRlSW5Cb3VuZHMuZm9yRWFjaChmdW5jdGlvbiAoYikgeyByZXR1cm4gYm91bmRzLmV4dGVuZChiKTsgfSk7XG4gICAgICAgIHJldHVybiBib3VuZHM7XG4gICAgfTtcbiAgICBGaXRCb3VuZHNTZXJ2aWNlLnByb3RvdHlwZS5hZGRUb0JvdW5kcyA9IGZ1bmN0aW9uIChsYXRMbmcpIHtcbiAgICAgICAgdmFyIGlkID0gdGhpcy5fY3JlYXRlSWRlbnRpZmllcihsYXRMbmcpO1xuICAgICAgICBpZiAodGhpcy5faW5jbHVkZUluQm91bmRzJC52YWx1ZS5oYXMoaWQpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG1hcCA9IHRoaXMuX2luY2x1ZGVJbkJvdW5kcyQudmFsdWU7XG4gICAgICAgIG1hcC5zZXQoaWQsIGxhdExuZyk7XG4gICAgICAgIHRoaXMuX2luY2x1ZGVJbkJvdW5kcyQubmV4dChtYXApO1xuICAgIH07XG4gICAgRml0Qm91bmRzU2VydmljZS5wcm90b3R5cGUucmVtb3ZlRnJvbUJvdW5kcyA9IGZ1bmN0aW9uIChsYXRMbmcpIHtcbiAgICAgICAgdmFyIG1hcCA9IHRoaXMuX2luY2x1ZGVJbkJvdW5kcyQudmFsdWU7XG4gICAgICAgIG1hcC5kZWxldGUodGhpcy5fY3JlYXRlSWRlbnRpZmllcihsYXRMbmcpKTtcbiAgICAgICAgdGhpcy5faW5jbHVkZUluQm91bmRzJC5uZXh0KG1hcCk7XG4gICAgfTtcbiAgICBGaXRCb3VuZHNTZXJ2aWNlLnByb3RvdHlwZS5jaGFuZ2VGaXRCb3VuZHNDaGFuZ2VTYW1wbGVUaW1lID0gZnVuY3Rpb24gKHRpbWVNcykge1xuICAgICAgICB0aGlzLl9ib3VuZHNDaGFuZ2VTYW1wbGVUaW1lJC5uZXh0KHRpbWVNcyk7XG4gICAgfTtcbiAgICBGaXRCb3VuZHNTZXJ2aWNlLnByb3RvdHlwZS5nZXRCb3VuZHMkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5ib3VuZHMkO1xuICAgIH07XG4gICAgRml0Qm91bmRzU2VydmljZS5wcm90b3R5cGUuX2NyZWF0ZUlkZW50aWZpZXIgPSBmdW5jdGlvbiAobGF0TG5nKSB7XG4gICAgICAgIHJldHVybiBsYXRMbmcubGF0ICsgXCIrXCIgKyBsYXRMbmcubG5nO1xuICAgIH07XG4gICAgRml0Qm91bmRzU2VydmljZS5jdG9yUGFyYW1ldGVycyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtcbiAgICAgICAgeyB0eXBlOiBNYXBzQVBJTG9hZGVyIH1cbiAgICBdOyB9O1xuICAgIEZpdEJvdW5kc1NlcnZpY2UgPSB0c2xpYl8xLl9fZGVjb3JhdGUoW1xuICAgICAgICBJbmplY3RhYmxlKCksXG4gICAgICAgIHRzbGliXzEuX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtNYXBzQVBJTG9hZGVyXSlcbiAgICBdLCBGaXRCb3VuZHNTZXJ2aWNlKTtcbiAgICByZXR1cm4gRml0Qm91bmRzU2VydmljZTtcbn0oKSk7XG5leHBvcnQgeyBGaXRCb3VuZHNTZXJ2aWNlIH07XG4iXX0=