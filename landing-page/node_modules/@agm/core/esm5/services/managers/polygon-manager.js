import * as tslib_1 from "tslib";
import { Injectable, NgZone } from '@angular/core';
import { merge, Observable } from 'rxjs';
import { map, skip, startWith, switchMap } from 'rxjs/operators';
import { createMVCEventObservable } from '../../utils/mvcarray-utils';
import { GoogleMapsAPIWrapper } from '../google-maps-api-wrapper';
import * as ɵngcc0 from '@angular/core';
var PolygonManager = /** @class */ (function () {
    function PolygonManager(_mapsWrapper, _zone) {
        this._mapsWrapper = _mapsWrapper;
        this._zone = _zone;
        this._polygons = new Map();
    }
    PolygonManager.prototype.addPolygon = function (path) {
        var polygonPromise = this._mapsWrapper.createPolygon({
            clickable: path.clickable,
            draggable: path.draggable,
            editable: path.editable,
            fillColor: path.fillColor,
            fillOpacity: path.fillOpacity,
            geodesic: path.geodesic,
            paths: path.paths,
            strokeColor: path.strokeColor,
            strokeOpacity: path.strokeOpacity,
            strokeWeight: path.strokeWeight,
            visible: path.visible,
            zIndex: path.zIndex,
        });
        this._polygons.set(path, polygonPromise);
    };
    PolygonManager.prototype.updatePolygon = function (polygon) {
        var _this = this;
        var m = this._polygons.get(polygon);
        if (m == null) {
            return Promise.resolve();
        }
        return m.then(function (l) { return _this._zone.run(function () { l.setPaths(polygon.paths); }); });
    };
    PolygonManager.prototype.setPolygonOptions = function (path, options) {
        return this._polygons.get(path).then(function (l) { l.setOptions(options); });
    };
    PolygonManager.prototype.deletePolygon = function (paths) {
        var _this = this;
        var m = this._polygons.get(paths);
        if (m == null) {
            return Promise.resolve();
        }
        return m.then(function (l) {
            return _this._zone.run(function () {
                l.setMap(null);
                _this._polygons.delete(paths);
            });
        });
    };
    PolygonManager.prototype.getPath = function (polygon) {
        return this._polygons.get(polygon)
            .then(function (polygon) { return polygon.getPath().getArray(); });
    };
    PolygonManager.prototype.getPaths = function (polygon) {
        return this._polygons.get(polygon)
            .then(function (polygon) { return polygon.getPaths().getArray().map(function (p) { return p.getArray(); }); });
    };
    PolygonManager.prototype.createEventObservable = function (eventName, path) {
        var _this = this;
        return new Observable(function (observer) {
            _this._polygons.get(path).then(function (l) {
                l.addListener(eventName, function (e) { return _this._zone.run(function () { return observer.next(e); }); });
            });
        });
    };
    PolygonManager.prototype.createPathEventObservable = function (agmPolygon) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var polygon, paths, pathsChanges$;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this._polygons.get(agmPolygon)];
                    case 1:
                        polygon = _a.sent();
                        paths = polygon.getPaths();
                        pathsChanges$ = createMVCEventObservable(paths);
                        return [2 /*return*/, pathsChanges$.pipe(startWith({ newArr: paths.getArray() }), // in order to subscribe to them all
                            switchMap(function (parentMVEvent) { return merge.apply(void 0, tslib_1.__spread(// rest parameter
                            parentMVEvent.newArr.map(function (chMVC, index) {
                                return createMVCEventObservable(chMVC)
                                    .pipe(map(function (chMVCEvent) { return ({ parentMVEvent: parentMVEvent, chMVCEvent: chMVCEvent, pathIndex: index }); }));
                            }))).pipe(startWith({ parentMVEvent: parentMVEvent, chMVCEvent: null, pathIndex: null })); }), // start the merged ob with an event signinifing change to parent
                            skip(1), // skip the manually added event
                            map(function (_a) {
                                var parentMVEvent = _a.parentMVEvent, chMVCEvent = _a.chMVCEvent, pathIndex = _a.pathIndex;
                                var retVal;
                                if (!chMVCEvent) {
                                    retVal = {
                                        newArr: parentMVEvent.newArr.map(function (subArr) { return subArr.getArray().map(function (latLng) { return latLng.toJSON(); }); }),
                                        eventName: parentMVEvent.evName,
                                        index: parentMVEvent.index,
                                    };
                                    if (parentMVEvent.previous) {
                                        retVal.previous = parentMVEvent.previous.getArray();
                                    }
                                }
                                else {
                                    retVal = {
                                        newArr: parentMVEvent.newArr.map(function (subArr) { return subArr.getArray().map(function (latLng) { return latLng.toJSON(); }); }),
                                        pathIndex: pathIndex,
                                        eventName: chMVCEvent.evName,
                                        index: chMVCEvent.index,
                                    };
                                    if (chMVCEvent.previous) {
                                        retVal.previous = chMVCEvent.previous;
                                    }
                                }
                                return retVal;
                            }))];
                }
            });
        });
    };
    PolygonManager.ctorParameters = function () { return [
        { type: GoogleMapsAPIWrapper },
        { type: NgZone }
    ]; };
    PolygonManager = tslib_1.__decorate([ tslib_1.__metadata("design:paramtypes", [GoogleMapsAPIWrapper, NgZone])
    ], PolygonManager);
PolygonManager.ɵfac = function PolygonManager_Factory(t) { return new (t || PolygonManager)(ɵngcc0.ɵɵinject(GoogleMapsAPIWrapper), ɵngcc0.ɵɵinject(ɵngcc0.NgZone)); };
PolygonManager.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: PolygonManager, factory: function (t) { return PolygonManager.ɵfac(t); } });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(PolygonManager, [{
        type: Injectable
    }], function () { return [{ type: GoogleMapsAPIWrapper }, { type: ɵngcc0.NgZone }]; }, null); })();
    return PolygonManager;
}());
export { PolygonManager };

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIkM6L1VzZXJzL3VzZXIvRGVza3RvcC9QUk9KRUNUUy9TVFVBTkEvSWRleVBheS90b3ZvLWFuZ3VsYXItOS1hcHAtbGFuZGluZy1wYWdlL25vZGVfbW9kdWxlcy9AYWdtL2NvcmUvZXNtNS9zZXJ2aWNlcy9tYW5hZ2Vycy9wb2x5Z29uLW1hbmFnZXIuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Ozs7QUFNQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O3lDQWtIeUMsQUFFbEM7Ozs7Ozt1R0FDZ0IiLCJmaWxlIjoicG9seWdvbi1tYW5hZ2VyLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgdHNsaWJfMSBmcm9tIFwidHNsaWJcIjtcbmltcG9ydCB7IEluamVjdGFibGUsIE5nWm9uZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgbWVyZ2UsIE9ic2VydmFibGUgfSBmcm9tICdyeGpzJztcbmltcG9ydCB7IG1hcCwgc2tpcCwgc3RhcnRXaXRoLCBzd2l0Y2hNYXAgfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XG5pbXBvcnQgeyBjcmVhdGVNVkNFdmVudE9ic2VydmFibGUgfSBmcm9tICcuLi8uLi91dGlscy9tdmNhcnJheS11dGlscyc7XG5pbXBvcnQgeyBHb29nbGVNYXBzQVBJV3JhcHBlciB9IGZyb20gJy4uL2dvb2dsZS1tYXBzLWFwaS13cmFwcGVyJztcbnZhciBQb2x5Z29uTWFuYWdlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBQb2x5Z29uTWFuYWdlcihfbWFwc1dyYXBwZXIsIF96b25lKSB7XG4gICAgICAgIHRoaXMuX21hcHNXcmFwcGVyID0gX21hcHNXcmFwcGVyO1xuICAgICAgICB0aGlzLl96b25lID0gX3pvbmU7XG4gICAgICAgIHRoaXMuX3BvbHlnb25zID0gbmV3IE1hcCgpO1xuICAgIH1cbiAgICBQb2x5Z29uTWFuYWdlci5wcm90b3R5cGUuYWRkUG9seWdvbiA9IGZ1bmN0aW9uIChwYXRoKSB7XG4gICAgICAgIHZhciBwb2x5Z29uUHJvbWlzZSA9IHRoaXMuX21hcHNXcmFwcGVyLmNyZWF0ZVBvbHlnb24oe1xuICAgICAgICAgICAgY2xpY2thYmxlOiBwYXRoLmNsaWNrYWJsZSxcbiAgICAgICAgICAgIGRyYWdnYWJsZTogcGF0aC5kcmFnZ2FibGUsXG4gICAgICAgICAgICBlZGl0YWJsZTogcGF0aC5lZGl0YWJsZSxcbiAgICAgICAgICAgIGZpbGxDb2xvcjogcGF0aC5maWxsQ29sb3IsXG4gICAgICAgICAgICBmaWxsT3BhY2l0eTogcGF0aC5maWxsT3BhY2l0eSxcbiAgICAgICAgICAgIGdlb2Rlc2ljOiBwYXRoLmdlb2Rlc2ljLFxuICAgICAgICAgICAgcGF0aHM6IHBhdGgucGF0aHMsXG4gICAgICAgICAgICBzdHJva2VDb2xvcjogcGF0aC5zdHJva2VDb2xvcixcbiAgICAgICAgICAgIHN0cm9rZU9wYWNpdHk6IHBhdGguc3Ryb2tlT3BhY2l0eSxcbiAgICAgICAgICAgIHN0cm9rZVdlaWdodDogcGF0aC5zdHJva2VXZWlnaHQsXG4gICAgICAgICAgICB2aXNpYmxlOiBwYXRoLnZpc2libGUsXG4gICAgICAgICAgICB6SW5kZXg6IHBhdGguekluZGV4LFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5fcG9seWdvbnMuc2V0KHBhdGgsIHBvbHlnb25Qcm9taXNlKTtcbiAgICB9O1xuICAgIFBvbHlnb25NYW5hZ2VyLnByb3RvdHlwZS51cGRhdGVQb2x5Z29uID0gZnVuY3Rpb24gKHBvbHlnb24pIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIG0gPSB0aGlzLl9wb2x5Z29ucy5nZXQocG9seWdvbik7XG4gICAgICAgIGlmIChtID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbS50aGVuKGZ1bmN0aW9uIChsKSB7IHJldHVybiBfdGhpcy5fem9uZS5ydW4oZnVuY3Rpb24gKCkgeyBsLnNldFBhdGhzKHBvbHlnb24ucGF0aHMpOyB9KTsgfSk7XG4gICAgfTtcbiAgICBQb2x5Z29uTWFuYWdlci5wcm90b3R5cGUuc2V0UG9seWdvbk9wdGlvbnMgPSBmdW5jdGlvbiAocGF0aCwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5fcG9seWdvbnMuZ2V0KHBhdGgpLnRoZW4oZnVuY3Rpb24gKGwpIHsgbC5zZXRPcHRpb25zKG9wdGlvbnMpOyB9KTtcbiAgICB9O1xuICAgIFBvbHlnb25NYW5hZ2VyLnByb3RvdHlwZS5kZWxldGVQb2x5Z29uID0gZnVuY3Rpb24gKHBhdGhzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBtID0gdGhpcy5fcG9seWdvbnMuZ2V0KHBhdGhzKTtcbiAgICAgICAgaWYgKG0gPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtLnRoZW4oZnVuY3Rpb24gKGwpIHtcbiAgICAgICAgICAgIHJldHVybiBfdGhpcy5fem9uZS5ydW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGwuc2V0TWFwKG51bGwpO1xuICAgICAgICAgICAgICAgIF90aGlzLl9wb2x5Z29ucy5kZWxldGUocGF0aHMpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgUG9seWdvbk1hbmFnZXIucHJvdG90eXBlLmdldFBhdGggPSBmdW5jdGlvbiAocG9seWdvbikge1xuICAgICAgICByZXR1cm4gdGhpcy5fcG9seWdvbnMuZ2V0KHBvbHlnb24pXG4gICAgICAgICAgICAudGhlbihmdW5jdGlvbiAocG9seWdvbikgeyByZXR1cm4gcG9seWdvbi5nZXRQYXRoKCkuZ2V0QXJyYXkoKTsgfSk7XG4gICAgfTtcbiAgICBQb2x5Z29uTWFuYWdlci5wcm90b3R5cGUuZ2V0UGF0aHMgPSBmdW5jdGlvbiAocG9seWdvbikge1xuICAgICAgICByZXR1cm4gdGhpcy5fcG9seWdvbnMuZ2V0KHBvbHlnb24pXG4gICAgICAgICAgICAudGhlbihmdW5jdGlvbiAocG9seWdvbikgeyByZXR1cm4gcG9seWdvbi5nZXRQYXRocygpLmdldEFycmF5KCkubWFwKGZ1bmN0aW9uIChwKSB7IHJldHVybiBwLmdldEFycmF5KCk7IH0pOyB9KTtcbiAgICB9O1xuICAgIFBvbHlnb25NYW5hZ2VyLnByb3RvdHlwZS5jcmVhdGVFdmVudE9ic2VydmFibGUgPSBmdW5jdGlvbiAoZXZlbnROYW1lLCBwYXRoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHJldHVybiBuZXcgT2JzZXJ2YWJsZShmdW5jdGlvbiAob2JzZXJ2ZXIpIHtcbiAgICAgICAgICAgIF90aGlzLl9wb2x5Z29ucy5nZXQocGF0aCkudGhlbihmdW5jdGlvbiAobCkge1xuICAgICAgICAgICAgICAgIGwuYWRkTGlzdGVuZXIoZXZlbnROYW1lLCBmdW5jdGlvbiAoZSkgeyByZXR1cm4gX3RoaXMuX3pvbmUucnVuKGZ1bmN0aW9uICgpIHsgcmV0dXJuIG9ic2VydmVyLm5leHQoZSk7IH0pOyB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIFBvbHlnb25NYW5hZ2VyLnByb3RvdHlwZS5jcmVhdGVQYXRoRXZlbnRPYnNlcnZhYmxlID0gZnVuY3Rpb24gKGFnbVBvbHlnb24pIHtcbiAgICAgICAgcmV0dXJuIHRzbGliXzEuX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgcG9seWdvbiwgcGF0aHMsIHBhdGhzQ2hhbmdlcyQ7XG4gICAgICAgICAgICByZXR1cm4gdHNsaWJfMS5fX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDogcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5fcG9seWdvbnMuZ2V0KGFnbVBvbHlnb24pXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgcG9seWdvbiA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhdGhzID0gcG9seWdvbi5nZXRQYXRocygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcGF0aHNDaGFuZ2VzJCA9IGNyZWF0ZU1WQ0V2ZW50T2JzZXJ2YWJsZShwYXRocyk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgcGF0aHNDaGFuZ2VzJC5waXBlKHN0YXJ0V2l0aCh7IG5ld0FycjogcGF0aHMuZ2V0QXJyYXkoKSB9KSwgLy8gaW4gb3JkZXIgdG8gc3Vic2NyaWJlIHRvIHRoZW0gYWxsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoTWFwKGZ1bmN0aW9uIChwYXJlbnRNVkV2ZW50KSB7IHJldHVybiBtZXJnZS5hcHBseSh2b2lkIDAsIHRzbGliXzEuX19zcHJlYWQoLy8gcmVzdCBwYXJhbWV0ZXJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnRNVkV2ZW50Lm5ld0Fyci5tYXAoZnVuY3Rpb24gKGNoTVZDLCBpbmRleCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY3JlYXRlTVZDRXZlbnRPYnNlcnZhYmxlKGNoTVZDKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnBpcGUobWFwKGZ1bmN0aW9uIChjaE1WQ0V2ZW50KSB7IHJldHVybiAoeyBwYXJlbnRNVkV2ZW50OiBwYXJlbnRNVkV2ZW50LCBjaE1WQ0V2ZW50OiBjaE1WQ0V2ZW50LCBwYXRoSW5kZXg6IGluZGV4IH0pOyB9KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkpKS5waXBlKHN0YXJ0V2l0aCh7IHBhcmVudE1WRXZlbnQ6IHBhcmVudE1WRXZlbnQsIGNoTVZDRXZlbnQ6IG51bGwsIHBhdGhJbmRleDogbnVsbCB9KSk7IH0pLCAvLyBzdGFydCB0aGUgbWVyZ2VkIG9iIHdpdGggYW4gZXZlbnQgc2lnbmluaWZpbmcgY2hhbmdlIHRvIHBhcmVudFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNraXAoMSksIC8vIHNraXAgdGhlIG1hbnVhbGx5IGFkZGVkIGV2ZW50XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWFwKGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcGFyZW50TVZFdmVudCA9IF9hLnBhcmVudE1WRXZlbnQsIGNoTVZDRXZlbnQgPSBfYS5jaE1WQ0V2ZW50LCBwYXRoSW5kZXggPSBfYS5wYXRoSW5kZXg7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZXRWYWw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghY2hNVkNFdmVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0VmFsID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld0FycjogcGFyZW50TVZFdmVudC5uZXdBcnIubWFwKGZ1bmN0aW9uIChzdWJBcnIpIHsgcmV0dXJuIHN1YkFyci5nZXRBcnJheSgpLm1hcChmdW5jdGlvbiAobGF0TG5nKSB7IHJldHVybiBsYXRMbmcudG9KU09OKCk7IH0pOyB9KSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBldmVudE5hbWU6IHBhcmVudE1WRXZlbnQuZXZOYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4OiBwYXJlbnRNVkV2ZW50LmluZGV4LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwYXJlbnRNVkV2ZW50LnByZXZpb3VzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0VmFsLnByZXZpb3VzID0gcGFyZW50TVZFdmVudC5wcmV2aW91cy5nZXRBcnJheSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0VmFsID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld0FycjogcGFyZW50TVZFdmVudC5uZXdBcnIubWFwKGZ1bmN0aW9uIChzdWJBcnIpIHsgcmV0dXJuIHN1YkFyci5nZXRBcnJheSgpLm1hcChmdW5jdGlvbiAobGF0TG5nKSB7IHJldHVybiBsYXRMbmcudG9KU09OKCk7IH0pOyB9KSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXRoSW5kZXg6IHBhdGhJbmRleCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBldmVudE5hbWU6IGNoTVZDRXZlbnQuZXZOYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4OiBjaE1WQ0V2ZW50LmluZGV4LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjaE1WQ0V2ZW50LnByZXZpb3VzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0VmFsLnByZXZpb3VzID0gY2hNVkNFdmVudC5wcmV2aW91cztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmV0VmFsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pKV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgUG9seWdvbk1hbmFnZXIuY3RvclBhcmFtZXRlcnMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbXG4gICAgICAgIHsgdHlwZTogR29vZ2xlTWFwc0FQSVdyYXBwZXIgfSxcbiAgICAgICAgeyB0eXBlOiBOZ1pvbmUgfVxuICAgIF07IH07XG4gICAgUG9seWdvbk1hbmFnZXIgPSB0c2xpYl8xLl9fZGVjb3JhdGUoW1xuICAgICAgICBJbmplY3RhYmxlKCksXG4gICAgICAgIHRzbGliXzEuX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtHb29nbGVNYXBzQVBJV3JhcHBlciwgTmdab25lXSlcbiAgICBdLCBQb2x5Z29uTWFuYWdlcik7XG4gICAgcmV0dXJuIFBvbHlnb25NYW5hZ2VyO1xufSgpKTtcbmV4cG9ydCB7IFBvbHlnb25NYW5hZ2VyIH07XG4iXX0=